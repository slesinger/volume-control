esphome:
  name: volume-control
  platformio_options:
    build_flags:
      - -DUSER_SETUP_LOADED=1
      - -DST7789_DRIVER=1
      - -DTFT_WIDTH=240
      - -DTFT_HEIGHT=240
      - -std=gnu++14
      - -DTFT_MOSI=23
      - -DTFT_SCLK=18
      - -DTFT_CS=-1    # CS pin not used
      - -DTFT_DC=16    # Data Command control pin
      - -DTFT_RST=4    # Reset pin
      - -DLOAD_GLCD=1  # Load default font - keep for fallback
      - -DLOAD_FONT2=1 # Load smooth Font2 - smaller font for header
      - -DLOAD_FONT4=1 # Load smooth Font4 - main UI font
      - -DLOAD_FONT8=1 # Load smooth Font8 - volume display
      - -DSPI_FREQUENCY=40000000
      - -DDISABLE_ALL_LIBRARY_WARNINGS=1  # Disable the touch CS warning
      - -Isrc # Base source directory
      - -Isrc/esphome/components/api
      - -Isrc/esphome/components/binary_sensor
      - -Isrc/esphome/components/logger
      - -Isrc/esphome/components/ota
      - -Isrc/esphome/components/psram
      - -Isrc/esphome/components/wifi
      - -Isrc/esphome/components/spi              # The MOST IMPORTANT one

esp32:
  board: lolin32
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

network:
    enable_ipv6: true
    min_ipv6_addr_count: 2

logger:
  level: INFO
  # Available levels: NONE, ERROR, WARN, INFO, DEBUG, VERBOSE
  # Set to NONE to completely disable logging
  # Set to ERROR for minimal logging
  # Set to INFO for normal logging without debug messages

psram:

api:
  encryption:
    key: !secret encryption_key
  services:
    - service: set_volume
      variables:
        level: float
      then:
        - lambda: 'id(my_vol_ctrl).set_volume_from_hass(level);'
    
    - service: toggle_mute
      then:
        - lambda: 'id(my_vol_ctrl).toggle_mute();'
    
    - service: volume_up
      then:
        - lambda: 'id(my_vol_ctrl).volume_change_from_hass(1);'
    
    - service: volume_down
      then:
        - lambda: 'id(my_vol_ctrl).volume_change_from_hass(-1);'

ota:
  platform: esphome
  password: !secret ota_password

spi:
  id: spi1
  clk_pin: GPIO18
  mosi_pin: GPIO23

packages:
  time: !include time.yaml

external_components:
  - source:
      type: local
      path: custom_components

# Use our custom component
output:
  - platform: ledc
    id: backlight_output
    pin: GPIO17
    frequency: 1000Hz
    min_power: 0.1
    max_power: 1.0

vol_ctrl:
  id: my_vol_ctrl
  spi_id: spi1
  backlight_pin: backlight_output

sensor:
  - platform: rotary_encoder
    id: volume_encoder
    pin_a: GPIO32
    pin_b: GPIO33
    min_value: -200  # Allow for plenty of negative and positive movement
    max_value: 200
    resolution: 1
    on_value:
      then:
        - lambda: |-
            static int last_value = 0;
            
            // Calculate relative change since last update
            int diff = x - last_value;
            
            if (diff != 0) {  // Only process if there's actual movement
              // Always explicitly request current volume from speakers through the vol_ctrl component
              // This ensures we use the speaker's volume as the source of truth
              id(my_vol_ctrl).process_encoder_change(diff);
              
              // Update our position tracking
              last_value = x;
            }

binary_sensor:
  - platform: gpio
    pin: 
      number: GPIO25
      mode: INPUT_PULLUP
    name: "Encoder Button"
    id: encoder_button
    filters:
      - invert:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - lambda: 'id(my_vol_ctrl).button_pressed();'
    on_release:
      then:
        - lambda: 'id(my_vol_ctrl).button_released();'